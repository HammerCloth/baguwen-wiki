<!--yml
category: 未分类
date: 0001-01-01 00:00:00
-->

# 841.分步式锁,程序数据库中死锁机制及解决⽅案

> 原文：[https://zwmst.com/4941.html](https://zwmst.com/4941.html)

   [ *并发编程面试专栏* ](https://zwmst.com/%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%e9%9d%a2%e8%af%95%e4%b8%93%e6%a0%8f)*[ <time datetime="2021-10-13T23:45:48+08:00"> 2021-10-13 </time> ](https://zwmst.com/4941.html)  基本原理：⽤⼀个状态值表示锁，对锁的占⽤和释放通过状态值来标识。

1.  三种分布式锁：
    1.  Zookeeper：基于zookeeper瞬时有序节点实现的分布式锁，其主要逻辑如下。⼤致思想即为：每个客户端对某个功能加锁时，在zookeeper上的与该功能对应的指定节点的⽬录下，⽣成⼀个唯⼀的瞬时有序节点。判断是否获取锁的⽅式很简单，只需要判断有序节点中序号最⼩的⼀个。当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁⽆法释放，⽽产⽣的死锁问题。
    2.  优点
        锁安全性⾼，zk可持久化，且能实时监听获取锁的客户端状态。⼀旦客户端宕机，则瞬时节点随之消失，zk因⽽能第⼀时间释放锁。这也省去了⽤分布式缓存实现锁的过程中需要加⼊超时时间判断的这⼀逻辑。
    3.  缺点
        性能开销⽐较⾼。因为其需要动态产⽣、销毁瞬时节点来实现锁功能。所以不太适合直接提供给⾼并发的场景使⽤。
    4.  实现
        可以直接采⽤zookeeper第三⽅库curator即可⽅便地实现分布式锁。
    5.  适⽤场景
        对可靠性要求⾮常⾼，且并发程度不⾼的场景下使⽤。如核⼼数据的定时全量/增量同步等。
2.  memcached：memcached带有add函数，利⽤add函数的特性即可实现分布式锁。add和set的区别在于：如果多线程并发set，则每个set都会成功，但最后存储的值以最后的set的线程为准。⽽add的话则相反，add会添加第⼀个到达的值，并返回true，后续的添加则都会返回false。利⽤该点即可很轻松地实现分布式锁。
    2.  优点
        并发⾼效
    3.  缺点
        memcached采⽤列⼊LRU置换策略，所以如果内存不够，可能导致缓存中的锁信息丢失。
        memcached⽆法持久化，⼀旦重启，将导致信息丢失。
    4.  使⽤场景
        ⾼并发场景。需要 1)加上超时时间避免死锁; 2)提供⾜够⽀撑锁服务的内存空间; 3)稳定的集群化管理。
3.  redis：redis分布式锁即可以结合zk分布式锁锁⾼度安全和memcached并发场景下效率很好的优点，其实现⽅式和memcached类似，采⽤setnx即可实现。需要注意的是，这⾥的redis也需要设置超时时间，以避免死锁。可以利⽤jedis客户端实现。

    ```
    1 ICacheKey cacheKey = new ConcurrentCacheKey(key, type);
    2 return RedisDao.setnx(cacheKey, "1");
    ```*