<!--yml
category: 未分类
date: 0001-01-01 00:00:00
-->

# 1010.Linux 中主要有哪几种内核锁?

> 原文：[https://zwmst.com/5307.html](https://zwmst.com/5307.html)

   [ *Linux* ](https://zwmst.com/linux)*[ <time datetime="2021-10-21T23:20:30+08:00"> 2021-10-21 </time> ](https://zwmst.com/5307.html)  Linux 的同步机制从 2.0 到 2.6 以来不断发展完善。从最初的原子操作,到后来的信号量,从大内核锁到今天的自旋锁。这些同步机制的发展伴随 Linux 从单处理器到对称多处理器的过渡;
伴随着从非抢占内核到抢占内核的过度。Linux 的锁机制越来越有效,也越来越复杂。
Linux 的内核锁主要是自旋锁和信号量。
自旋锁最多只能被一个可执行线程持有,如果一个执行线程试图请求一个已被争用(已经被持有)的自旋锁,那么这个线程就会一直进行忙循环——旋转——等待锁重新可用。要是锁未被争用,请求它的执行线程便能立刻得到它并且继续进行。自旋锁可以在任何时刻防止多于一个的执行线程同时进入临界区。
Linux 中的信号量是一种睡眠锁。如果有一个任务试图获得一个已被持有的信号量时,信号量会将其推入等待队列,然后让其睡眠。这时处理器获得自由去执行其它代码。当持有信号量的进程将信号量释放后,在等待队列中的一个任务将被唤醒,从而便可以获得这个信号量。
信号量的睡眠特性,使得信号量适用于锁会被长时间持有的情况;只能在进程上下文中使用,因为中断上下文中是不能被调度的;另外当代码持有信号量时,不可以再持有自旋锁。
Linux 内核中的同步机制:原子操作、信号量、读写信号量和自旋锁的 API,另外一些同步机制,包括大内核锁、读写锁、大读者锁、RCU (Read-Copy Update,顾名思义就是读-拷贝修改),和顺序锁。*