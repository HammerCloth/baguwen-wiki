<!--yml
category: 未分类
date: 0001-01-01 00:00:00
--->

# 853.⾼并发系统如何做性能优化？如何防⽌库存超卖？

> 原文：[https://zwmst.com/4967.html](https://zwmst.com/4967.html)

   [ *并发编程面试专栏* ](https://zwmst.com/%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%e9%9d%a2%e8%af%95%e4%b8%93%e6%a0%8f)*[ <time datetime="2021-10-14T00:26:15+08:00"> 2021-10-13 </time> ](https://zwmst.com/4967.html)  1.  ⾼并发系统性能优化：优化程序，优化服务配置，优化系统配置
    1.  尽量使⽤缓存，包括⽤户缓存，信息缓存等，多花点内存来做缓存，可以⼤量减少与数据库的交互，提⾼性能。
    2.  ⽤jprofiler等⼯具找出性能瓶颈，减少额外的开销。
    3.  优化数据库查询语句，减少直接使⽤hibernate等⼯具的直接⽣成语句（仅耗时较⻓的查询做优化）。
    4.  优化数据库结构，多做索引，提⾼查询效率。
    5.  统计的功能尽量做缓存，或按每天⼀统计或定时统计相关报表，避免需要时进⾏统计的功能。
    6.  能使⽤静态⻚⾯的地⽅尽量使⽤，减少容器的解析（尽量将动态内容⽣成静态html来显示）。
    7.  解决以上问题后，使⽤服务器集群来解决单台的瓶颈问题。
2.  防⽌库存超卖：
    1.  悲观锁：在更新库存期间加锁，不允许其它线程修改；
        1.  数据库锁：select xxx for update；
        2.  分布式锁；
    2.  乐观锁：使⽤带版本号的更新。每个线程都可以并发修改，但在并发时，只有⼀个线程会修改成功，其它会返回失败。
        1.  redis watch：监视键值对，作⽤时如果事务提交exec时发现监视的监视对发⽣变化，事务将被取消。
3.  消息队列：通过 FIFO 队列，使修改库存的操作串⾏化。
4.  总结：总的来说，不能把压⼒放在数据库上，所以使⽤ "select xxx for update" 的⽅式在⾼并发的场景下是不可⾏的。FIFO 同步队列的⽅式，可以结合库存限制队列⻓，但是在库存较多的场景下，⼜不太适⽤。所以相对来说，我会倾向于选择：乐观锁 / 缓存锁 / 分布式锁的⽅式。*