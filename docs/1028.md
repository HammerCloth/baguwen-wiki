<!--yml
category: 未分类
date: 0001-01-01 00:00:00
-->

# 你将如何使用 thread dump？你将如何分析Thread dump？

> 原文：[https://zwmst.com/2122.html](https://zwmst.com/2122.html)

   [ *Java高并发* ](https://zwmst.com/java%e9%ab%98%e5%b9%b6%e5%8f%91)*[ <time datetime="2021-08-18T16:28:46+08:00"> 2021-08-18 </time> ](https://zwmst.com/2122.html)  ## 新建状态（New）

用 new 语句创建的线程处于新建状态，此时它和其他 Java 对象一样，仅仅在堆区中被分配了内存。

## 就绪状态（Runnable）

当一个线程对象创建后，其他线程调用它的 start()方法，该线程就进入就绪状态，Java虚拟机会为它创建方法调用栈和程序计数器。处于这个状态的线程位于可运行池中，等待获得 CPU 的使用权。

## 运行状态（Running）

处于这个状态的线程占用 CPU，执行程序代码。只有处于就绪状态的线程才有机会转到运行状态。

## 阻塞状态（Blocked）

阻塞状态是指线程因为某些原因放弃 CPU，暂时停止运行。当线程处于阻塞状态时，Java 虚拟机不会给线程分配 CPU。直到线程重新进入就绪状态，它才有机会转到运行状态。

## 阻塞状态可分为以下 3 种：

### 位于对象等待池中的阻塞状态（Blocked in object’s wait pool）：

当线程处于运行状态时，如果执行了某个对象的 wait()方法，Java 虚拟机就会
把线程放到这个对象的等待池中，这涉及到“线程通信”的内容。

### 位于对象锁池中的阻塞状态（Blocked in object’s lock pool）：

当线程处于运行状态时，试图获得某个对象的同步锁时，如果该对象的同步锁已经被其他线程占用，Java 虚拟机就会把这个线程放到这个对象的锁池中，这涉及到“线程同步”的内容。

### 其他阻塞状态（Otherwise Blocked）：

当前线程执行了 sleep()方法，或者调用了其他线程的 join()方法，或者发出了
I/O 请求时，就会进入这个状态。

## 死亡状态（Dead）

当线程退出 run()方法时，就进入死亡状态，该线程结束生命周期。*