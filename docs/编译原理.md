<!--yml
category: 未分类
date: 0001-01-01 00:00:00
-->

# 词法分析

> 原文：[https://zwmst.com/1364.html](https://zwmst.com/1364.html)

   [ *编译原理* ](https://zwmst.com/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86)*[ <time datetime="2021-08-15T11:12:18+08:00"> 2021-08-15 </time> ](https://zwmst.com/1364.html)  即对构成源程序的字符流进行扫描然后根据构词规则识别单词(也称单词符号或符号)。所以当 单词不符合构词规则时词法分析会报错。

读入一个一个的字符（输入），对这些字符进行扫描和分解，从而识别出一个个单词（输出）。*
<!--yml
category: 未分类
date: 0001-01-01 00:00:00
-->

# 语法分析

> 原文：[https://zwmst.com/1366.html](https://zwmst.com/1366.html)

   [ *编译原理* ](https://zwmst.com/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86)*[ <time datetime="2021-08-15T11:12:32+08:00"> 2021-08-15 </time> ](https://zwmst.com/1366.html)  语法分析是编译过程的一个逻辑阶段。语法分析的任务是在词法分析的基础上将单词序列组合 成各类语法短语，如“程序”，“语句”，“表达式”等等.语法分析程序判断源程序在结构上是否正确

在词法分析的基础上，将单词序列（输出）分解成各类语法短语。（赋值语句等语句） 语 法分析依据语言的语法规则，确定整个输入串是否在语法上正确。

If else是否匹配，无论是LL(1)文法分析，自顶向下还是自底向上都是要按照给定的语法，判 断词法分析的词语是不是满足语法要求（标识符定义是否正确，括号是否匹配，关键字是否正 确，标识符，函数定义是否正确，使用的函数或者标识符是否定义等等）*
<!--yml
category: 未分类
date: 0001-01-01 00:00:00
-->

# 语义分析

> 原文：[https://zwmst.com/1368.html](https://zwmst.com/1368.html)

   [ *编译原理* ](https://zwmst.com/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86)*[ <time datetime="2021-08-15T11:12:49+08:00"> 2021-08-15 </time> ](https://zwmst.com/1368.html)  审查源程序有无语义错误，为代码生成阶段收集类型信息（如类型转化，类型匹配，上下文相关性等）。

主要是类型相容检查，有以下几种：

各种条件表达式的类型是不是boolean型？

运算符的分量类型是否相容？

赋值语句的左右部的类型是否相容？

形参和实参的类型是否相容?

下标表达式的类型是否为所允许的类型？

函数说明中的函数类型和返回值的类型是否一致？

V[E]中的V是不是变量，而且是数组类型？

V.i中的V是不是变量，而且是记录类型？i是不是该记录的域名？

x+f(…)中的f是不是函数名？形参个数和实参个数是否一致？

每个使用性标识符是否都有声明？有无标识符的重复声明？

在语义分析同时产生中间代码，在这种模式下，语义分析的主要功能如下：

语义审查

在扫描声明部分时构造标识符的符号表

在扫描语句部分时产生中间代码*
<!--yml
category: 未分类
date: 0001-01-01 00:00:00
-->

# 中间代码生成

> 原文：[https://zwmst.com/1370.html](https://zwmst.com/1370.html)

   [ *编译原理* ](https://zwmst.com/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86)*[ <time datetime="2021-08-15T11:13:00+08:00"> 2021-08-15 </time> ](https://zwmst.com/1370.html)  中间代码是一种结构简单，含义明确的记号系统。

将源程序生成一种内部表示形式，这种内部表示形式叫中间代码。（四元式就是一种中间代 码形式）*
<!--yml
category: 未分类
date: 0001-01-01 00:00:00
-->

# 目标代码生成

> 原文：[https://zwmst.com/1372.html](https://zwmst.com/1372.html)

   [ *编译原理* ](https://zwmst.com/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86)*[ <time datetime="2021-08-15T11:13:12+08:00"> 2021-08-15 </time> ](https://zwmst.com/1372.html)  把中间代码变换成特定机器上的绝对指令代码或可重定位的指令代码或汇编指令代码,它的工 作与硬件系统和指令含义有关.*
<!--yml
category: 未分类
date: 0001-01-01 00:00:00
-->

# 表格管理程序

> 原文：[https://zwmst.com/1374.html](https://zwmst.com/1374.html)

   [ *编译原理* ](https://zwmst.com/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86)*[ <time datetime="2021-08-15T11:13:23+08:00"> 2021-08-15 </time> ](https://zwmst.com/1374.html)  编译过程中源程序的各种信息被保留在种种不同的表格里，编译各阶段的工作涉及到构造、 查找或更新有关的表格，因此需要有表格管理工作。*
<!--yml
category: 未分类
date: 0001-01-01 00:00:00
-->

# 出错处理

> 原文：[https://zwmst.com/1376.html](https://zwmst.com/1376.html)

   [ *编译原理* ](https://zwmst.com/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86)*[ <time datetime="2021-08-15T11:13:33+08:00"> 2021-08-15 </time> ](https://zwmst.com/1376.html)  出错处理：编译过程中，发现源程序有错误（词法错误、语法错误、语义错误），编译程序 应报告错误的性质和出错的地点，并将错误所造成的影响限制在尽可能小的范围内，使得源程序的其余部分继续被编译下去。这些工作称为出错处理(error handling)。目的是使得编译程序能够继续向下进行分析和处理。*
<!--yml
category: 未分类
date: 0001-01-01 00:00:00
-->

# 有穷自动机（有限自动机）

> 原文：[https://zwmst.com/1378.html](https://zwmst.com/1378.html)

   [ *编译原理* ](https://zwmst.com/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86)*[ <time datetime="2021-08-15T11:13:42+08:00"> 2021-08-15 </time> ](https://zwmst.com/1378.html)  为什么是有穷？：状态和输入字母表有穷。

作用：是一种识别装置，识别正规文法所定义的语言和正规式所表示的集合。

分类：

（i）确定的有穷自动机（DFA）

（ii）不确定的有穷自动机（NFA）*
<!--yml
category: 未分类
date: 0001-01-01 00:00:00
-->

# 全局优化

> 原文：[https://zwmst.com/1380.html](https://zwmst.com/1380.html)

   [ *编译原理* ](https://zwmst.com/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86)*[ <time datetime="2021-08-15T11:13:52+08:00"> 2021-08-15 </time> ](https://zwmst.com/1380.html)  过程内的全局优化是在一个程序过程（C语言内称为函数）范围内进行的优化，前面提到的所 有方法也都可用到全局优化当中。*