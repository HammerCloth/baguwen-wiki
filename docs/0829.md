<!--yml
category: 未分类
date: 0001-01-01 00:00:00
--->

# 常见的并发容器？

> 原文：[https://zwmst.com/1697.html](https://zwmst.com/1697.html)

   [ *Java高并发* ](https://zwmst.com/java%e9%ab%98%e5%b9%b6%e5%8f%91)*[ <time datetime="2021-08-15T16:15:19+08:00"> 2021-08-15 </time> ](https://zwmst.com/1697.html)  ConcurrentHashMap：使用了分段锁，锁的粒度变得更小，多线程访问时，可能都不存在锁 的竞争，所以大大提高了吞吐量。简单对比来看，就好比数据库上用行锁来取代表锁，行锁无 疑带来更大的并发。

CopyOnWriteArrayList：写入时复制，多线程访问时，彼此不会互相干扰或被修改的线程所 干扰，当然copy时有开销的，尤其时列表元素庞大，且写入操作频繁时，所以仅当迭代操作远 远大于修改操作时，才应该考虑使用。

BlockingQueue：阻塞队列提供了可阻塞的put和take方法，当队列已经满了，那么put操作

将阻塞到队列可用，当队列为空时，take操作会阻塞到队列里有数据。有界的队列是一种强大 的资源管理器，可以在程序负荷过载时保护应用，可作为一种服务降级的策略。阻塞队列还提 供offer操作，当数据无法加入队列时，返回失败状态，给应用主动处理负荷过载带来更多灵活 性。*