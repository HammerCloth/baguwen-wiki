<!--yml
category: 未分类
date: 0001-01-01 00:00:00
--->

# 835.如何检测死锁？怎么预防死锁？

> 原文：[https://zwmst.com/4929.html](https://zwmst.com/4929.html)

   [ *并发编程面试专栏* ](https://zwmst.com/%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%e9%9d%a2%e8%af%95%e4%b8%93%e6%a0%8f)*[ <time datetime="2021-10-13T23:12:39+08:00"> 2021-10-13 </time> ](https://zwmst.com/4929.html)  1.  概念：
    是指两个或两个以上的进程在执⾏过程中，因争夺资源⽽造成的⼀种互相等待的现象，若⽆外⼒作⽤，它们都将⽆法推进下去。此时称系统处于死锁；
2.  死锁的四个必要条件：
    1.  互斥条件：进程对所分配到的资源不允许其他进程进⾏访问，若其他进程访问该资源，只能等待，直⾄占有该资源的进程使⽤完成后释放该资源
    2.  请求和保持条件：进程获得⼀定的资源之后，⼜对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞，但⼜对⾃⼰获得的资源保持不放
    3.  不可剥夺条件：是指进程已获得的资源，在未完成使⽤之前，不可被剥夺，只能在使⽤完后⾃⼰释放
    4.  环路等待条件：是指进程发⽣死锁后，若⼲进程之间形成⼀种头尾相接的循环等待资源关系
3.  死锁产⽣的原因：
    1.因竞争资源发⽣死锁 现象：系统中供多个进程共享的资源的数⽬不⾜以满⾜全部进程的需要时，就会引起对诸资源的竞争⽽发⽣死锁现象
    2.进程推进顺序不当发⽣死锁
4.  检查死锁
    1.  有两个容器，⼀个⽤于保存线程正在请求的锁，⼀个⽤于保存线程已经持有的锁。每次加锁之前都会做如下检测:
    2.  检测当前正在请求的锁是否已经被其它线程持有,如果有，则把那些线程找出来
    3.  遍历第⼀步中返回的线程，检查⾃⼰持有的锁是否正被其中任何⼀个线程请求，如果第⼆步返回真,表示出现了死锁
5.  死锁的解除与预防：控制不要让四个必要条件成⽴。*