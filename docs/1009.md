<!--yml
category: 未分类
date: 0001-01-01 00:00:00
-->

# Zookeeper 的典型应用场景

> 原文：[https://zwmst.com/2081.html](https://zwmst.com/2081.html)

   [ *ZooKeeper* ](https://zwmst.com/zookeeper)*[ <time datetime="2021-08-17T11:23:05+08:00"> 2021-08-17 </time> ](https://zwmst.com/2081.html)  **Zookeeper**是一个典型的发布/订阅模式的分布式数据管理与协调框架，开发人员可以使用它来进行分布式数据的发布和订阅。
通过对**Zookeeper**中丰富的数据节点进行交叉使用，配合 Watcher 事件通知机制，可以非常方便的构建一系列分布式应用中年都会涉及的核心功能，如：

*   （1） 数据发布/订阅
*   （2） 负载均衡
*   （3） 命名服务
*   （4） 分布式协调/通知
*   （5） 集群管理
*   （6） Master 选 举
*   （7） 分布式锁
*   （8） 分布式队列

## 数据发布/订阅

### 介绍

数据发布/订阅系统，即所谓的配置中心，顾名思义就是发布者发布数据供订阅者进行数据订阅。

### 目的

动态获取数据（配置信息),实现数据（配置信息）的集中式管理和数据的动态更新设计模式

## Push 模式

### Pull 模 式

### 数据（配置信息）特性

*   （1） 数据量通常比较小
*   （2） 数据内容在运行时会发生动态更新
*   （3） 集群中各机器共享，配置一致
    如：机器列表信息、运行时开关配置、数据库配置信息等基于 Zookeeper 的实现方式

    ### 数据存储：

    将数据（配置信息）存储到 Zookeeper 上的一个数据节点

    ### 数据获取：

    应用在启动初始化节点从 Zookeeper 数据节点读取数据，并在该节点上注册一个数据变更 Watcher

    ### 数据变更：

    当变更数据时，更新 Zookeeper 对应节点数据，Zookeeper 会将数据变更通知发到各客户端，客户端接到通知后重新读取变更后的数据即可。

## 负载均衡

### zk 的命名服务

命名服务是指通过指定的名字来获取资源或者服务的地址，利用 zk 创建一个全局的路径，这个路径就可以作为一个名字，指向集群中的集群，提供的服务的地址，或者一个远程的对象等等。

### 分布式通知和协调

对于系统调度来说：操作人员发送通知实际是通过控制台改变某个节点的状态，然后 zk 将这些变化发送给注册了这个节点的 watcher 的所有客户端。对于执行情况汇报：每个工作进程都在某个目录下创建一个临时节点。并携带工作的进度数据，这样汇总的进程可以监控目录子节点的变化获得工作进度的实时的全局情况。

### zk 的命名服务（文件系统）

命名服务是指通过指定的名字来获取资源或者服务的地址，利用 zk 创建一个全局的路径，即是唯一的路径，这个路径就可以作为一个名字，指向集群中的集群，提供的服务的地址，或者一个远程的对象等等。

### zk 的配置管理（文件系统、通知机制）

程序分布式的部署在不同的机器上，将程序的配置信息放在 zk 的 znode 下， 当有配置发生改变时，也就是 znode 发生变化时，可以通过改变 zk 中某个目录节点的内容，利用 watcher 通知给各个客户端，从而更改配置。Zookeeper 集群管理（文件系统、通知机制）

## 所谓集群管理无在乎两点：是否有机器退出和加入、选举 master。

对于第一点，所有机器约定在父目录下创建临时目录节点，然后监听父目录节点
的子节点变化消息。一旦有机器挂掉，该机器与 zookeeper 的连接断开，其所创建的临时目录节点被删除，所有其他机器都收到通知：某个兄弟目录被删除，于是，所有人都知道：它上船了。
新机器加入也是类似，所有机器收到通知：新兄弟目录加入，highcount 又有了，
对于第二点，我们稍微改变一下，所有机器创建临时顺序编号目录节点， 每次选取编号最小的机器作为 master 就好。

## Zookeeper分布式锁（文件系统、通知机制）

有了 zookeeper 的一致性文件系统，锁的问题变得容易。锁服务可以分为两类，一个是保持独占，另一个是控制时序。
**对于第一类**，我们将 zookeeper 上的一个 znode 看作是一把锁，通过createznode 的方式来实现。所有客户端都去创建 /distribute_lock 节点， 最终成功创建的那个客户端也即拥有了这把锁。用完删除掉自己创建的 distribute_lock 节点就释放出锁。
**对于第二类**， /distribute_lock 已经预先存在，所有客户端在它下面创建临时顺序编号目录节点，和选 master 一样，编号最小的获得锁，用完删除，依次方便 。

## Zookeeper 队列管理（文件系统、通知机制）两种类型的队列：

*   （1） 同步队列，当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达。
*   （2） 队列按照 FIFO 方式进行入队和出队操作。
    **第一类**，在约定目录下创建临时目录节点，监听节点数目是否是我们要求的数目。
    **第二类**，和分布式锁服务中的控制时序场景基本原理一致，入列有编号，出列按编号。
    在特定的目录下创建 PERSISTENT_SEQUENTIAL 节点，创建成功时Watcher 通知等待的队列，队列删除序列号最小的节点用以消费。此场景下Zookeeper 的 znode 用于消息存储，znode 存储的数据就是消息队列中的消息内容，SEQUENTIAL 序列号就是消息的编号，按序取出即可。由于创建的节点是持久化的，所以不必担心队列消息的丢失问题。*