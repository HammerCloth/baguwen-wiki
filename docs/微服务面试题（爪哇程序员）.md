<!--yml
category: 微服务
date: 0001-01-01 00:00:00
-->

# 微服务面试题（爪哇程序员）

# 微服务有哪些优缺点？

> 原文：[https://zwmst.com/1047.html](https://zwmst.com/1047.html)

优点：

独立的可扩展性，每个微服务都可以独立进行横向或纵向扩展，根据业务实际增长情况来进行 快速扩展；

独立的可升级性，每个微服务都可以独立进行服务升级、更新，不用依赖于其它服务，结合持 续集成工具可以进行持续发布，开发人员就可以独立快速完成服务升级发布流程；

易维护性，每个微服务的代码均只专注于完成该单个业务范畴的事情，因此微服务项目代码数 量将减少至IDE可以快速加载的大小，这样可以提高了代码的可读性，进而可以提高研发人员的生产效率；

语言无关性，研发人员可以选用自己最为熟悉的语言和框架来完成他们的微服务项目（当然， 一般根据每个公司的实际技术栈需要来了），这样在面对新技术或新框架的选用时，微服务能够更好地进行快速响应；

故障和资源的隔离性，在系统中出现不好的资源操作行为时，例如内存泄露、数据库连接未关闭等情况，将仅仅只会影响单个微服务；

优化跨团队沟通，如果要完全实践微服务架构设计风格，研发团队势必会按照新的原则来进行 划分，由之前的按照技能、职能划分的方式变为按照业务（单个微服务）来进行划分，如此这般团队里将有各个方向技能的研发人员，沟通效率上来说要优于之前按照技能进行划分的组织架构；

原生基于“云”的系统架构设计，基于微服务架构设计风格，我们能构建出来原生对于“云”具 备超高友好度的系统，与常用容器工具如Docker能够很方便地结合，构建持续发布系统与 IaaS、PaaS平台对接，使其能够方便的部署于各类“云”上，如公用云、私有云以及混合云。

缺点：

增加了系统复杂性；

运维难度增加；

本地调用变成RPC调用，接口耗时增加；

可能会引入分布式事务。*


# 微服务有哪些特点？

> 原文：[https://zwmst.com/1049.html](https://zwmst.com/1049.html)

*   解耦 – 系统内的服务很大程度上是分离的。因此，整个应用程序可以轻松构建，更改和扩展

*   组件化 – 微服务被视为可以轻松更换和升级的独立组件

*   业务能力 – 微服务非常简单，专注于单一功能

*   自治 – 开发人员和团队可以彼此独立工作，从而提高速度

*   持续交付 – 通过软件创建，测试和批准的系统自动化，允许频繁发布软件

*   责任 – 微服务不关注应用程序作为项目。相反，他们将应用程序视为他们负责的产品

*   分散治理 – 重点是使用正确的工具来做正确的工作。这意味着没有标准化模式或任何技术模 式。开发人员可以自由选择最有用的工具来解决他们的问题

*   敏捷 – 微服务支持敏捷开发。任何新功能都可以快速开发并再次丢弃*


# 单片，SOA 和微服务架构有什么区别？

> 原文：[https://zwmst.com/1051.html](https://zwmst.com/1051.html)

*   单片架构类似于大容器，其中应用程序的所有软件组件组装在一起并紧密封装。

*   一个面向服务的架构（SOA）是一种相互通信服务的集合。通信可以涉及简单的数据传递，也 可以涉及两个或多个协调某些活动的服务。

*   微服务架构是一种架构风格，它将应用程序构建为以业务域为模型的小型自治服务集合。*


# Spring Cloud 解决了哪些问题？

> 原文：[https://zwmst.com/1053.html](https://zwmst.com/1053.html)

*   与分布式系统相关的复杂性 – 包括网络问题，延迟开销，带宽问题，安全问题。

*   处理服务发现的能力 – 服务发现允许集群中的进程和服务找到彼此并进行通信。

*   解决冗余问题 – 冗余问题经常发生在分布式系统中。

*   负载平衡 – 改进跨多个计算资源（例如计算机集群，网络链接，中央处理单元）的工作负载 分布。

*   减少性能问题 – 减少因各种操作开销导致的性能问题。*


# 服务注册和发现是什么意思？Spring Cloud 如何实现？

> 原文：[https://zwmst.com/1055.html](https://zwmst.com/1055.html)

当我们开始一个项目时，我们通常在属性文件中进行所有的配置。随着越来越多的服务开发和 部署，添加和修改这些属性变得更加复杂。有些服务可能会下降，而某些位置可能会发生变 化。手动更改属性可能会产生问题。 Eureka 服务注册和发现可以在这种情况下提供帮助。由 于所有服务都在 Eureka 服务器上注册并通过调用 Eureka 服务器完成查找，因此无需处理服 务地点的任何更改和处理。*


# Spring Cloud 和dubbo的区别?

> 原文：[https://zwmst.com/1057.html](https://zwmst.com/1057.html)

（1）服务调用方式 dubbo是RPC springcloud Rest Api

（2）注册中心,dubbo 是zookeeper springcloud是eureka，也可以是zookeeper

（3）服务网关,dubbo本身没有实现，只能通过其他第三方技术整合，springcloud有Zuul路 由网关，作为路由服务器，进行消费者的请求分发,springcloud支持断路器，与git完美集成 配置文件支持版本控制，事物总线实现配置文件的更新与服务自动装配等等一系列的微服务架 构要素。*


# 什么是微服务？

> 原文：[https://zwmst.com/1059.html](https://zwmst.com/1059.html)

微服务架构是一种架构模式或者说是一种架构风格，它提倡将单一应用程序划分成一组小的服 务，每个服务运行在其独立的自己的进程中，服务之间互相协调、互相配合，为用户提供最终 价值。 服务之间采用轻量级的通信机制互相沟通（通常是基于HTTP的RESTful API）。每个 服务都围绕着具体业务进行构建，并且能够被独立地部署到生产环境、类生产环境等。另外， 应尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选 择合适的语言、工具对其进行构建，可以有一个非常轻量级的集中式管理来协调这些服务，可 以使用不同的语言来编写服务，也可以使用不同的数据存储。

从技术维度来说：

微服务化的核心就是将传统的一站式应用，根据业务拆分成一个一个的服务，彻底地去耦合,每 一个微服务提供单个业务功能的服务，一个服务做一件事，从技术角度看就是一种小而独立的 处理过程，类似进程概念，能够自行单独启动或销毁，拥有自己独立的数据库。*


# 微服务之间是如何通讯的？

> 原文：[https://zwmst.com/1061.html](https://zwmst.com/1061.html)

第一种：远程过程调用（Remote Procedure Invocation） 直接通过远程过程调用来访问别的service。 示例：REST、gRPC、Apache、Thrift

优点：

简单，常见。因为没有中间件代理，系统更简单

缺点：

只支持请求/响应的模式，不支持别的，比如通知、请求/异步响应、发布/订阅、发布/异步响 应降低了可用性，因为客户端和服务端在请求过程中必须都是可用的

第二种：消息

使用异步消息来做服务间通信。服务间通过消息管道来交换消息，从而通信。 示例：Apache Kafka、RabbitMQ

优点:

把客户端和服务端解耦，更松耦合 提高可用性，因为消息中间件缓存了消息，直到消费者可以 消费 支持很多通信机制比如通知、请求/异步响应、发布/订阅、发布/异步响应

缺点:

消息中间件有额外的复杂性*


# 请谈谈对SpringBoot 和SpringCloud的理解

> 原文：[https://zwmst.com/1063.html](https://zwmst.com/1063.html)

SpringBoot专注于快速方便的开发单个个体微服务。

SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来，为各个微服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务

SpringBoot可以离开SpringCloud独立使用开发项目，但是SpringCloud离不开 SpringBoot，属于依赖的关系。

SpringBoot专注于快速、方便的开发单个微服务个体，SpringCloud关注全局的服务治理框 架。

Spring Boot可以离开Spring Cloud独立使用开发项目，但是Spring Cloud离不开Spring Boot，属于依赖的关系。*


# 什么是服务熔断，什么是服务降级

> 原文：[https://zwmst.com/1065.html](https://zwmst.com/1065.html)

服务熔断

熔断机制是应对雪崩效应的一种微服务链路保护机制。当扇出链路的某个微服务不可用或者响 应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回”错误”的响应信 息。当检测到该节点微服务调用响应正常后恢复调用链路。在SpringCloud框架里熔断机制通 过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒 内20次调用失败就会启动熔断机制。熔断机制的注解是@HystrixCommand。

服务降级

其实就是线程池中单个线程障处理，防止单个线程请求时间太长，导致资源长期被占有而得不 到释放，从而导致线程池被快速占用完，导致服务崩溃。

Hystrix能解决如下问题：

请求超时降级，线程资源不足降级，降级之后可以返回自定义数据 线程池隔离降级，分布式服务可以针对不同的服务使用不同的线程池，从而互不影响 自动触发降级与恢复 实现请求缓存和请求合并*


# 你所知道的微服务技术栈有哪些？

> 原文：[https://zwmst.com/1067.html](https://zwmst.com/1067.html)

服务开发Springboot、Spring、SpringMVC

服务配置与管理Netflix公司的Archaius、阿里的Diamond等

服务注册与发现Eureka、Consul、Zookeeper等

服务调用Rest、RPC、gRPC

服务熔断器Hystrix、Envoy等

负载均衡Ribbon、Nginx等

服务接口调用(客户端调用服务的简化工具)Feign等

消息队列Kafka、RabbitMQ、ActiveMQ等

服务配置中心管理SpringCloudConfig、Chef等

服务路由（API网关）Zuul等

服务监控Zabbix、Nagios、Metrics、Spectator等

全链路追踪Zipkin，Brave、Dapper等

服务部署Docker、OpenStack、Kubernetes等

数据流操作开发包SpringCloud Stream（封装与Redis,Rabbit、Kafka等发送接收消息）

事件消息总线Spring Cloud Bus*


# 什么是 Eureka服务注册与发现？

> 原文：[https://zwmst.com/1069.html](https://zwmst.com/1069.html)

Eureka是Netflix的一个子模块，也是核心模块之一。Eureka是一个基于REST的服务，用于 定位服务，以实现云端中间层服务发现和故障转移。服务注册与发现对于微服务架构来说是非 常重要的，有了服务发现与注册，只需要使用服务的标识符，就可以访问到服务，而不需要修 改服务调用的配置文件了。功能类似于dubbo的注册中心，比如Zookeeper。*


# Eureka的基本架构是什么？

> 原文：[https://zwmst.com/1071.html](https://zwmst.com/1071.html)

Spring Cloud 封装了 Netflix 公司开发的 Eureka 模块来实现服务注册和发现(请对比 Zookeeper)。

Eureka 采用了 C-S 的设计架构。Eureka Server 作为服务注册功能的服务器，它是服务注册 中心。

而系统中的其他微服务，使用 Eureka 的客户端连接到 Eureka Server并维持心跳连接。这样 系统的维护人员就可以通过 Eureka Server 来监控系统中各个微服务是否正常运行。 SpringCloud 的一些其他模块（比如Zuul）就可以通过 Eureka Server 来发现系统中的其他 微服务，并执行相关的逻辑。

Eureka包含两个组件： Eureka Server 和 Eureka Client

Eureka Server提供服务注册服务各个节点启动后，会在EurekaServer中进行注册，这样 EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在 界面中直观的看到

EurekaClient是一个Java客户端用于简化Eureka Server的交互，客户端同时也具备一个内置 的、使用轮询(round-robin)负载算法的负载均衡器。在应用启动后，将会向Eureka Server 发送心跳(默认周期为30秒)。如果Eureka Server在多个心跳周期内没有接收到某个节点的心 跳，EurekaServer将会从服务注册表中把这个服务节点移除（默认90秒）*


# 作为服务注册中心，Eureka比Zookeeper好在哪里?

> 原文：[https://zwmst.com/1073.html](https://zwmst.com/1073.html)

著名的CAP理论指出，一个分布式系统不可能同时满足C(一致性)、A(可用性)和P(分区容错 性)。由于分区容错性P在是分布式系统中必须要保证的，因此我们只能在A和C之间进行权衡。

因此，Zookeeper 保证的是CP, Eureka 则是AP。

Zookeeper保证CP

当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不 能接受服务直接down掉不可用。也就是说，服务注册功能对可用性的要求要高于一致性。但 是zk会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会 重新进行leader选举。问题在于，选举leader的时间太长，30~120s,且选举期间整个zk集群 都是不可用的，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因网络问题使得zk集 群失去master节点是较大概率会发生的事，虽然服务能够最终恢复，但是漫长的选举时间导致 的注册长期不可用是不能容忍的。

Eureka保证AP

Eureka看明白了这一点，因此在设计时就优先保证可用性。Eureka各个节点都是平等的，几 个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的 客户端在向某个Eureka注册或时如果发现连接失败，则会自动切换至其它节点，只要有一台 Eureka还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保 证强一致性)。

除此之外，Eureka还有一种自我保护机制，如果在15分钟内超过85%的节点都没有正常的心 跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况：

Eureka不再从注册列表中移除因为长时间没收到心跳而应该过期的服务 Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(即保证当前节 点依然可用) 当网络稳定时，当前实例新的注册信息会被同步到其它节点中 因此， Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像 zookeeper那样使整个注册服务瘫痪。*


# 273.服务注册发现

> 原文：[https://zwmst.com/3536.html](https://zwmst.com/3536.html)

服务注册就是维护一个登记簿，它管理系统内所有的服务地址。当新的服务启动后，它会向登记簿交待自己的地址信息。服务的依赖方直接向登记簿要 Service Provider 地址就行了。当下用于服务注册的工具非常多 ZooKeeper，Consul，Etcd, 还有 Netflix 家的 eureka 等。服务注册有两种形式：客户端注册和第三方注册。*


# 274.客户端注册（zookeeper）

> 原文：[https://zwmst.com/3539.html](https://zwmst.com/3539.html)

客户端注册是服务自身要负责注册与注销的工作。当服务启动后向注册中心注册自身，当服务下线时注销自己。期间还需要和注册中心保持心跳。心跳不一定要客户端来做，也可以由注册中心负责（这个过程叫探活）。这种方式的缺点是注册工作与服务耦合在一起，不同语言都要实现一套注册逻辑。*


# 275.第三方注册（独立的服务 Registrar）

> 原文：[https://zwmst.com/3541.html](https://zwmst.com/3541.html)

第三方注册由一个独立的服务Registrar负责注册与注销。当服务启动后以某种方式通知Registrar，然后 Registrar 负责向注册中心发起注册工作。同时注册中心要维护与服务之间的心跳，当服务不可用时，向注册中心注销服务。这种方式的缺点是 Registrar 必须是一个高可用的系统，否则注册工作没法进展。*


# 276.客户端发现

> 原文：[https://zwmst.com/3544.html](https://zwmst.com/3544.html)

客户端发现是指客户端负责查询可用服务地址，以及负载均衡的工作。这种方式最方便直接，而且也方便做负载均衡。再者一旦发现某个服务不可用立即换另外一个，非常直接。缺点也在于多语言时的重复工作，每个语言实现相同的逻辑。*


# 277.服务端发现

> 原文：[https://zwmst.com/3546.html](https://zwmst.com/3546.html)

服务端发现需要额外的 Router 服务，请求先打到 Router，然后 Router 负责查询服务与负载均衡。这种方式虽然没有客户端发现的缺点，但是它的缺点是保证 Router 的高可用。*


# 278.API 网关

> 原文：[https://zwmst.com/3548.html](https://zwmst.com/3548.html)

API Gateway 是一个服务器，也可以说是进入系统的唯一节点。这跟面向对象设计模式中的Facade 模式很像。API Gateway 封装内部系统的架构，并且提供 API 给各个客户端。它还可能有其他功能，如授权、监控、负载均衡、缓存、请求分片和管理、静态响应处理等。

**API Gateway 负责请求转发、合成和协议转换**。所有来自客户端的请求都要先经过 API Gateway，然后路由这些请求到对应的微服务。API Gateway 将经常通过调用多个微服务来处理一个请求以及聚合多个服务的结果。它可以在 web 协议与内部使用的非 Web 友好型协议间进行转换，如HTTP 协议、WebSocket 协议。*


# 279.请求转发

> 原文：[https://zwmst.com/3550.html](https://zwmst.com/3550.html)

服务转发主要是对客户端的请求安装微服务的负载转发到不同的服务上*


# 280.响应合并

> 原文：[https://zwmst.com/3552.html](https://zwmst.com/3552.html)

把业务上需要调用多个服务接口才能完成的工作合并成一次调用对外统一提供服务。*


# 281.协议转换

> 原文：[https://zwmst.com/3554.html](https://zwmst.com/3554.html)

重点是支持 SOAP，JMS，Rest 间的协议转换。*


# 282.数据转换

> 原文：[https://zwmst.com/3556.html](https://zwmst.com/3556.html)

重点是支持 XML 和 Json 之间的报文格式转换能力（可选）*


# 283.安全认证

> 原文：[https://zwmst.com/3558.html](https://zwmst.com/3558.html)

1.  基于 Token 的客户端访问控制和安全策略
2.  传输数据和报文加密，到服务端解密，需要在客户端有独立的 SDK 代理包
3.  基于 Https 的传输加密，客户端和服务端数字证书支持
4.  基于 OAuth2.0 的服务安全认证(授权码，客户端，密码模式等）*


# 284.配置中心

> 原文：[https://zwmst.com/3560.html](https://zwmst.com/3560.html)

配置中心一般用作系统的参数配置，它需要满足如下几个要求：高效获取、实时感知、分布式访问。*


# 285.zookeeper 配置中心

> 原文：[https://zwmst.com/3562.html](https://zwmst.com/3562.html)

实现的架构图如下所示，采取数据加载到内存方式解决高效获取的问题，借助 zookeeper 的节点监听机制来实现实时感知。![](img/14cbba52f1e9b182f3238cde955e3d13.png)*


# 286.配置中心数据分类

> 原文：[https://zwmst.com/3569.html](https://zwmst.com/3569.html)

![](img/a6afe413345bd4b5d395e4e94a87272a.png)*


# 287.事件调度（kafka）

> 原文：[https://zwmst.com/3572.html](https://zwmst.com/3572.html)

消息服务和事件的统一调度，常用用 kafka ，activemq 等。*


# 288.服务跟踪（starter-sleuth）

> 原文：[https://zwmst.com/3574.html](https://zwmst.com/3574.html)

随着微服务数量不断增长，需要跟踪一个请求从一个微服务到下一个微服务的传播过程， **Spring Cloud Sleuth 正是解决这个问题，它在日志中引入唯一 ID，以保证微服务调用之间的一致性，这样你就能跟踪某个请求是如何从一个微服务传递到下一个**。

1.  为了实现请求跟踪，当请求发送到分布式系统的入口端点时，只需要服务跟踪框架为该请求创建一个唯一的跟踪标识，同时在分布式系统内部流转的时候，框架始终保持传递该唯一标识，直到返回给请求方为止，**这个唯一标识就是前文中提到的 Trace ID**。通过 Trace ID 的记录，我们就能将所有请求过程日志关联起来。
2.  为了统计各处理单元的时间延迟，当请求达到各个服务组件时，或是处理逻辑到达某个状态时，也通过一个唯一标识来标记它的开始、具体过程以及结束，该标识就是我们前文中提到的 Span ID，**对于每个 Span 来说，它必须有开始和结束两个节点，通过记录开始 Span 和结束 Span 的时间戳，就能统计出该 Span 的时间延迟**，除了时间戳记录之外，它还可以包含一些其他元数据，比如：事件名称、请求信息等。
3.  在快速入门示例中，我们轻松实现了日志级别的跟踪信息接入，这完全归功于spring-cloud-starter-sleuth 组件的实现。在 Spring Boot 应用中，通过在工程中引入 spring-cloud-starter-sleuth 依赖之后， 它会自动的为当前应用构建起各通信通道的跟踪机制，比如：
    1.  通过诸如 RabbitMQ、Kafka（或者其他任何 Spring Cloud Stream 绑定器实现的消息中间件）传递的请求。
    2.  通过 Zuul 代理传递的请求。
    3.  通过 RestTemplate 发起的请求。*


# 289.服务熔断（Hystrix）

> 原文：[https://zwmst.com/3577.html](https://zwmst.com/3577.html)

在微服务架构中通常会有多个服务层调用，基础服务的故障可能会导致级联故障，进而造成整个系统不可用的情况，这种现象被称为服务雪崩效应。服务雪崩效应是一种因“服务提供者”的不可用导致“服务消费者”的不可用,并将不可用逐渐放大的过程。

熔断器的原理很简单，如同电力过载保护器。它可以实现快速失败，如果它在一段时间内侦测到许多类似的错误，**会强迫其以后的多个调用快速失败，不再访问远程服务器，从而防止应用程序不断地尝试执行可能会失败的操作**，使得应用程序继续执行而不用等待修正错误，或者浪费 CPU时间去等到长时间的超时产生。熔断器也可以使应用程序能够诊断错误是否已经修正，如果已经修正，应用程序会再次尝试调用操作。*


# 290.Hystrix 断路器机制

> 原文：[https://zwmst.com/3579.html](https://zwmst.com/3579.html)

断路器很好理解, 当 Hystrix Command 请求后端服务失败数量超过一定比例(默认 50%), 断路器会切换到开路状态(Open). 这时所有请求会直接失败而不会发送到后端服务. 断路器保持在开路状态一段时间后(默认 5 秒), 自动切换到半开路状态(HALF-OPEN). 这时会判断下一次请求的返回情况, 如果请求成功, 断路器切回闭路状态(CLOSED), 否则重新切换到开路状态(OPEN). Hystrix 的断路器就像我们家庭电路中的保险丝, 一旦后端服务不可用, 断路器会直接切断请求链, 避免发送大量无效请求影响系统吞吐量, 并且断路器有自我检测并恢复的能力。*


# 291.API 管理

> 原文：[https://zwmst.com/3581.html](https://zwmst.com/3581.html)

SwaggerAPI 管理工具*


# 432.负载均衡

> 原文：[https://zwmst.com/3920.html](https://zwmst.com/3920.html)

负载均衡 建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。*


# 433.四层负载均衡 vs 七层负载均衡

> 原文：[https://zwmst.com/3927.html](https://zwmst.com/3927.html)

![](img/fabca521fe0d2b12703d46d19d348fbe.png)*


# 434.四层负载均衡（目标地址和端口交换）

> 原文：[https://zwmst.com/3930.html](https://zwmst.com/3930.html)

主要通过报文中的目标地址和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。
以常见的 TCP 为例，**负载均衡设备在接收到第一个来自客户端的 SYN 请求时，即通过上述方式选择一个最佳的服务器，并对报文中目标 IP 地址进行修改(改为后端服务器 IP），直接转发给该服务器**。TCP 的连接建立，**即三次握手是客户端和服务器直接建立的，负载均衡设备只是起到一个类似路由器的转发动作**。在某些部署情况下，为保证服务器回包可以正确返回给负载均衡设备，在转发报文的同时可能还会对报文原来的源地址进行修改。实现四层负载均衡的软件有：

**F5：硬件负载均衡器，功能很好，但是成本很高。
lvs：重量级的四层负载软件。
nginx：轻量级的四层负载软件，带缓存功能，正则表达式较灵活。
haproxy：模拟四层转发，较灵活**。*


# 435.七层负载均衡（内容交换）

> 原文：[https://zwmst.com/3932.html](https://zwmst.com/3932.html)

所谓七层负载均衡，也称为“内容交换”，也就是主要通过报文中的真正有意义的应用层内容，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。

七层应用负载的好处，是使得整个网络更智能化。例如访问一个网站的用户流量，可以通过七层的方式，将对图片类的请求转发到特定的图片服务器并可以使用缓存技术；将对文字类的请求可以转发到特定的文字服务器并可以使用压缩技术。实现七层负载均衡的软件有：
 **haproxy：天生负载均衡技能，全面支持七层代理，会话保持，标记，路径转移；
nginx：只在 http 协议和 mail 协议上功能比较好，性能与 haproxy 差不多；
apache：功能较差
Mysql proxy：功能尚可。***


# 436.轮循均衡（Round Robin）

> 原文：[https://zwmst.com/3936.html](https://zwmst.com/3936.html)

每一次来自网络的请求轮流分配给内部中的服务器，从 1 至 N 然后重新开始。此种均衡算法适合于服务器组中的所有服务器都有相同的软硬件配置并且平均服务请求相对均衡的情况。*


# 437.权重轮循均衡（Weighted Round Robin）

> 原文：[https://zwmst.com/3938.html](https://zwmst.com/3938.html)

根据服务器的不同处理能力，给每个服务器分配不同的权值，使其能够接受相应权值数的服务请求。例如：服务器 A 的权值被设计成 1，B 的权值是 3，C 的权值是 6，则服务器 A、B、C 将分别接受到 10%、30％、60％的服务请求。此种均衡算法能确保高性能的服务器得到更多的使用率，避免低性能的服务器负载过重。*


# 438.随机均衡（Random）

> 原文：[https://zwmst.com/3940.html](https://zwmst.com/3940.html)

把来自网络的请求随机分配给内部中的多个服务器。*


# 439.权重随机均衡（Weighted Random）

> 原文：[https://zwmst.com/3942.html](https://zwmst.com/3942.html)

此种均衡算法类似于权重轮循算法，不过在处理请求分担时是个随机选择的过程。*


# 440.响应速度均衡（Response Time 探测时间）

> 原文：[https://zwmst.com/3944.html](https://zwmst.com/3944.html)

**负载均衡设备对内部各服务器发出一个探测请求（例如 Ping），然后根据内部中各服务器对探测请求的最快响应时间来决定哪一台服务器来响应客户端的服务请求。**此种均衡算法能较好的反映服务器的当前运行状态，但这最快响应时间仅仅指的是负载均衡设备与服务器间的最快响应时间，而不是客户端与服务器间的最快响应时间。*


# 441\. 最少连接数均衡（Least Connection）

> 原文：[https://zwmst.com/3946.html](https://zwmst.com/3946.html)

最少连接数均衡算法对内部中需负载的每一台服务器都有一个数据记录，记录当前该服务器正在处理的连接数量，当有新的服务连接请求时，将把当前请求分配给连接数最少的服务器，使均衡更加符合实际情况，负载更加均衡。此种均衡算法适合长时处理的请求服务，如 FTP。*


# 442.处理能力均衡（CPU、内存）

> 原文：[https://zwmst.com/3948.html](https://zwmst.com/3948.html)

此种均衡算法将把服务请求分配给内部中处理负荷（根据服务器 CPU 型号、CPU 数量、内存大小及当前连接数等换算而成）最轻的服务器，由于考虑到了内部服务器的处理能力及当前网络运行状况，所以此种均衡算法相对来说更加精确，尤其适合运用到第七层（应用层）负载均衡的情况下。*


# 443.DNS 响应均衡（Flash DNS）

> 原文：[https://zwmst.com/3950.html](https://zwmst.com/3950.html)

在此均衡算法下，分处在不同地理位置的负载均衡设备收到同一个客户端的域名解析请求，并在同一时间内把此域名解析成各自相对应服务器的 IP 地址并返回给客户端，则客户端将以最先收到的域名解析 IP 地址来继续请求服务，而忽略其它的 IP 地址响应。在种均衡策略适合应用在全局负载均衡的情况下，对本地负载均衡是没有意义的。*


# 444.哈希算法

> 原文：[https://zwmst.com/3952.html](https://zwmst.com/3952.html)

一致性哈希一致性 Hash，相同参数的请求总是发到同一提供者。当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。*


# 445.IP 地址散列（保证客户端服务器对应关系稳定）

> 原文：[https://zwmst.com/3954.html](https://zwmst.com/3954.html)

通过管理发送方 IP 和目的地 IP 地址的散列，将来自同一发送方的分组(或发送至同一目的地的分组)统一转发到相同服务器的算法。当客户端有一系列业务需要处理而必须和一个服务器反复通信时，该算法能够以流(会话)为单位，保证来自相同客户端的通信能够一直在同一服务器中进行处理。*


# 446.URL 散列

> 原文：[https://zwmst.com/3959.html](https://zwmst.com/3959.html)

通过管理客户端请求 URL 信息的散列，将发送至相同 URL 的请求转发至同一服务器的算法。*


# 447.LVS 原理

> 原文：[https://zwmst.com/3961.html](https://zwmst.com/3961.html)

### IPVS

LVS 的 IP 负载均衡技术是通过 IPVS 模块来实现的，IPVS 是 LVS 集群系统的核心软件，它的主要作用是：安装在 Director Server 上，同时在 Director Server 上虚拟出一个 IP 地址，用户必须通过这个虚拟的 IP 地址访问服务器。这个虚拟 IP 一般称为 LVS 的 VIP，即 Virtual IP。访问的请求首先经过 VIP 到达负载调度器，然后由负载调度器从 Real Server 列表中选取一个服务节点响应用户的请求。 在用户的请求到达负载调度器后，调度器如何将请求发送到提供服务的 Real Server 节点，而 Real Server 节点如何返回数据给用户，是 IPVS 实现的重点技术。

ipvs ： 工作于内核空间，主要用于使用户定义的策略生效
ipvsadm : 工作于用户空间，主要用于用户定义和管理集群服务的工具

ipvs 工作于内核空间的 INPUT 链上，当收到用户请求某集群服务时，经过 PREROUTING 链，经检查本机路由表，送往 INPUT 链；在进入 netfilter 的 INPUT 链时，ipvs 强行将请求报文通过ipvsadm 定义的集群服务策略的路径改为 FORWORD 链，将报文转发至后端真实提供服务的主机。*


# 448.LVS NAT 模式

> 原文：[https://zwmst.com/3964.html](https://zwmst.com/3964.html)

![](img/c7f2b4e5412c8d5bc057fe76dd897af9.png)

1.  客户端将请求发往前端的负载均衡器，请求报文源地址是 CIP(客户端 IP),后面统称为 CIP)，目标地址为 VIP(负载均衡器前端地址，后面统称为 VIP)。
2.  负载均衡器收到报文后，发现请求的是在规则里面存在的地址，那么它将客户端请求报文的目标地址改为了后端服务器的 RIP 地址并将报文根据算法发送出去。
3.  报文送到 Real Server 后，由于报文的目标地址是自己，所以会响应该请求，并将响应报文返还给 LVS。
4.  然后 lvs 将此报文的源地址修改为本机并发送给客户端。

注意：在 NAT 模式中，Real Server 的网关必须指向 LVS，否则报文无法送达客户端

### 特点：

1.  NAT 技术将请求的报文和响应的报文都需要通过 LB 进行地址改写，因此网站访问量比较大的时候 LB 负载均衡调度器有比较大的瓶颈，一般要求最多之能 10-20 台节点
2.  只需要在 LB 上配置一个公网 IP 地址就可以了。
3.  每台内部的 realserver 服务器的网关地址必须是调度器 LB 的内网地址。
4.  NAT 模式支持对 IP 地址和端口进行转换。即用户请求的端口和真实服务器的端口可以不一致。

### 优点：

集群中的物理服务器可以使用任何支持 TCP/IP 操作系统，只有负载均衡器需要一个合法的 IP 地址。

### 缺点：

扩展性有限。当服务器节点（普通 PC 服务器）增长过多时,负载均衡器将成为整个系统的瓶颈，因为所有的请求包和应答包的流向都经过负载均衡器。当服务器节点过多时，大量的数据包都交汇在负载均衡器那，速度就会变慢！*


# 449.LVS DR 模式（局域网改写 mac 地址）

> 原文：[https://zwmst.com/3967.html](https://zwmst.com/3967.html)

![](img/beca7ab523a8cfdaac911db566d59a47.png)

1.  客户端将请求发往前端的负载均衡器，请求报文源地址是 CIP，目标地址为 VIP。
2.  负载均衡器收到报文后，发现请求的是在规则里面存在的地址，那么它将客户端请求报文的源MAC 地址改为自己 DIP 的 MAC 地址，目标 MAC 改为了 RIP 的 MAC 地址，并将此包发送给 RS。
3.  RS 发现请求报文中的目的 MAC 是自己，就会将次报文接收下来，处理完请求报文后，将响应报文通过 lo 接口送给 eth0 网卡直接发送给客户端。

注意：需要设置 lo 接口的 VIP 不能响应本地网络内的 arp 请求。

### 总结：

1.  通过在调度器 LB 上修改数据包的目的 MAC 地址实现转发。注意源地址仍然是 CIP，目的地址仍然是 VIP 地址。
2.  请求的报文经过调度器，而 RS 响应处理后的报文无需经过调度器 LB，因此并发访问量大时使用效率很高（和 NAT 模式比）
3.  因为 DR 模式是通过 MAC 地址改写机制实现转发，因此所有 RS 节点和调度器 LB 只能在一个局域网里面
4.  RS 主机需要绑定 VIP 地址在 LO 接口（掩码 32 位）上，并且需要配置 ARP 抑制。
5.  RS 节点的默认网关不需要配置成 LB，而是直接配置为上级路由的网关，能让 RS 直接出网就可以。
6.  由于 DR 模式的调度器仅做 MAC 地址的改写，所以调度器 LB 就不能改写目标端口，那么 RS 服务器就得使用和 VIP 相同的端口提供服务。
7.  直接对外的业务比如 WEB 等，RS 的 IP 最好是使用公网 IP。对外的服务，比如数据库等最好使用内网 IP。

### 优点：

和 TUN（隧道模式）一样，负载均衡器也只是分发请求，应答包通过单独的路由方法返回给客户端。与 VS-TUN 相比，VS-DR 这种实现方式不需要隧道结构，因此可以使用大多数操作系统做为物理服务器。

DR 模式的效率很高，但是配置稍微复杂一点，因此对于访问量不是特别大的公司可以用haproxy/nginx取代。日1000-2000W PV或者并发请求1万一下都可以考虑用haproxy/nginx。

### 缺点：

所有 RS 节点和调度器 LB 只能在一个局域网里面*


# 450.LVS TUN 模式（IP 封装、跨网段）

> 原文：[https://zwmst.com/3970.html](https://zwmst.com/3970.html)

![](img/8360880307367ee76e1323bd2913a4c1.png)

1.  客户端将请求发往前端的负载均衡器，请求报文源地址是 CIP，目标地址为 VIP。
2.  负载均衡器收到报文后，发现请求的是在规则里面存在的地址，那么它将在客户端请求报文的首部再封装一层 IP 报文,将源地址改为 DIP，目标地址改为 RIP,并将此包发送给 RS。
3.  RS 收到请求报文后，会首先拆开第一层封装,然后发现里面还有一层 IP 首部的目标地址是自己lo 接口上的 VIP，所以会处理次请求报文，并将响应报文通过 lo 接口送给 eth0 网卡直接发送给客户端。

注意：需要设置 lo 接口的 VIP 不能在共网上出现。

### 总结：

1.  TUNNEL 模式必须在所有的 realserver 机器上面绑定 VIP 的 IP 地址
2.  TUNNEL 模式的 vip ——>realserver 的包通信通过 TUNNEL 模式，不管是内网和外网都能通信，所以不需要 lvs vip 跟 realserver 在同一个网段内。
3.  TUNNEL 模式 realserver 会把 packet 直接发给 client 不会给 lvs 了
4.  TUNNEL 模式走的隧道模式，所以运维起来比较难，所以一般不用。

### 优点：

负载均衡器只负责将请求包分发给后端节点服务器，而 RS 将应答包直接发给用户。所以，减少了负载均衡器的大量数据流动，负载均衡器不再是系统的瓶颈，就能处理很巨大的请求量，这种方式，一台负载均衡器能够为很多 RS 进行分发。而且跑在公网上就能进行不同地域的分发。

### 缺点：

隧道模式的 RS 节点需要合法 IP，这种方式需要所有的服务器支持”IP Tunneling”(IP Encapsulation)协议，服务器可能只局限在部分 Linux 系统上。*


# 451.LVS FULLNAT 模式

> 原文：[https://zwmst.com/3973.html](https://zwmst.com/3973.html)

无论是 DR 还是 NAT 模式，不可避免的都有一个问题：LVS 和 RS 必须在同一个 VLAN 下，否则LVS 无法作为 RS 的网关。这引发的两个问题是：

1.  同一个 VLAN 的限制导致运维不方便，跨 VLAN 的 RS 无法接入。
2.  LVS 的水平扩展受到制约。当 RS 水平扩容时，总有一天其上的单点 LVS 会成为瓶颈。

Full-NAT 由此而生，解决的是 LVS 和 RS 跨 VLAN 的问题，而跨 VLAN 问题解决后，LVS 和 RS 不再存在 VLAN 上的从属关系，可以做到多个 LVS 对应多个 RS，解决水平扩容的问题。Full-NAT 相比 NAT 的主要改进是，在 SNAT/DNAT 的基础上，加上另一种转换，转换过程如下：
![](img/4a3f767950b84b7f027474308df43593.png)

1.  在包从 LVS 转到 RS 的过程中，源地址从客户端 IP 被替换成了 LVS 的内网 IP。内网 IP 之间可以通过多个交换机跨 VLAN 通信。目标地址从 VIP 修改为 RS IP.
2.  当 RS 处理完接受到的包，处理完成后返回时，将目标地址修改为 LVS ip，原地址修改为 RS IP，最终将这个包返回给 LVS 的内网 IP，这一步也不受限于 VLAN。
3.  LVS 收到包后，在 NAT 模式修改源地址的基础上，再把 RS 发来的包中的目标地址从 LVS 内网 IP 改为客户端的 IP,并将原地址修改为 VIP。

Full-NAT 主要的思想是把网关和其下机器的通信，改为了普通的网络通信，从而解决了跨 VLAN 的问题。采用这种方式，LVS 和 RS 的部署在 VLAN 上将不再有任何限制，大大提高了运维部署的便利性。

### 总结

1.  FULL NAT 模式不需要 LBIP 和 realserver ip 在同一个网段；
2.  full nat 因为要更新 sorce ip 所以性能正常比 nat 模式下降 10%*


# 452.Keepalive

> 原文：[https://zwmst.com/3977.html](https://zwmst.com/3977.html)

keepalive 起初是为 LVS 设计的，专门用来监控 lvs 各个服务节点的状态，后来加入了 vrrp 的功能，因此除了 lvs，也可以作为其他服务（nginx，haproxy）的高可用软件。VRRP 是 virtual router redundancy protocal（虚拟路由器冗余协议）的缩写。VRRP 的出现就是为了解决静态路由出现的单点故障，它能够保证网络可以不间断的稳定的运行。所以 keepalive 一方面具有 LVS cluster node healthcheck 功能，另一方面也具有 LVS director failover。*


# 453.Nginx 反向代理负载均衡

> 原文：[https://zwmst.com/3979.html](https://zwmst.com/3979.html)

普通的负载均衡软件，如 LVS，其实现的功能只是对请求数据包的转发、传递，从负载均衡下的节点服务器来看，接收到的请求还是来自访问负载均衡器的客户端的真实用户；而反向代理就不一样了，反向代理服务器在接收访问用户请求后，会代理用户 重新发起请求代理下的节点服务器，最后把数据返回给客户端用户。在节点服务器看来，访问的节点服务器的客户端用户就是反向代理服务器，而非真实的网站访问用户。*


# 454.upstream_module 和健康检测

> 原文：[https://zwmst.com/3981.html](https://zwmst.com/3981.html)

**ngx_http_upstream_module 是负载均衡模块，可以实现网站的负载均衡功能即节点的健康检查**，upstream 模块允许 Nginx 定义一组或多组节点服务器组，使用时可通过 proxy_pass 代理方式把网站的请求发送到事先定义好的对应 Upstream 组 的名字上。

| upstream 模块 内参数 | 参数说明 |
| --- | --- |
| weight | 服务器权重 |
| max_fails Nginx | 尝试连接后端主机失败的此时，这是值是配合 proxy_next_upstream、fastcgi_next_upstream 和 memcached_next_upstream 这三个参数来使用的。当 Nginx接收后端服务器返回这三个参数定义的状态码时，会将这个请求转发给正常工作的的后端服务器。如 404、503、503,max_files=1 |
| fail_timeout | max_fails 和 fail_timeout 一般会关联使用，如果某台 server 在 fail_timeout 时间内出现了max_fails 次连接失败，那么 Nginx 会认为其已经挂掉，从而在 fail_timeout 时间内不再去请求它，fail_timeout 默认是 10s，max_fails 默认是 1，即默认情况只要是发生错误就认为服务器挂了，如果将 max_fails 设置为 0，则表示取消这项检查 |
| backup | 表示当前 server 是备用服务器，只有其它非 backup 后端服务器都挂掉了或很忙才会分配请求给它down 标志服务器永远不可用，可配合 ip_hash 使用 |

```
upstream lvsServer{
 server 191.168.1.11 weight=5 ;
 server 191.168.1.22:82;
 server example.com:8080 max_fails=2 fail_timeout=10s backup;
 #域名的话需要解析的哦，内网记得 hosts
}
```*


# 455.proxy_pass 请求转发

> 原文：[https://zwmst.com/3983.html](https://zwmst.com/3983.html)

proxy_pass 指令属于 ngx_http_proxy_module 模块，此模块可以将请求转发到另一台服务器，在实际的反向代理工作中，**会通过 location 功能匹配指定的 URI，然后把接收到服务匹配 URI 的
请求通过 proyx_pass 抛给定义好的 upstream 节点池。**

```
location /download/ {
 proxy_pass http://download/vedio/;
}
#这是前端代理节点的设置
13/04/2018 Page 213 of 283
#交给后端 upstream 为 download 的节点
```

| proxy 模块参数 | 说明 |
| --- | --- |
| proxy_next_upstream | 什么情况下将请求传递到下一个 upstream |
| proxy_limite_rate | 限制从后端服务器读取响应的速率 |
| proyx_set_header | 设置 http 请求 header 传给后端服务器节点，如：可实现让代理后端的服务器节点获取访问客户端的这是 ip |
| client_body_buffer_size | 客户端请求主体缓冲区大小 |
| proxy_connect_timeout | 代理与后端节点服务器连接的超时时间 |
| proxy_send_timeout | 后端节点数据回传的超时时间 |
| proxy_read_timeout | 设置 Nginx 从代理的后端服务器获取信息的时间，表示连接成功建立后，Nginx 等待后端服务器的响应时间 |
| proxy_buffer_size | 设置缓冲区大小 |
| proxy_buffers | 设置缓冲区的数量和大小 |
| proyx_busy_buffers_size | 用于设置系统很忙时可以使用的 proxy_buffers 大小，推荐为proxy_buffers*2 |
| proxy_temp_file_write_size | 指定 proxy 缓存临时文件的大小 |*