<!--yml
category: 未分类
date: 0001-01-01 00:00:00
--->

# 744.常用的几种线程池并讲讲其中的工作原理。

> 原文：[https://zwmst.com/4738.html](https://zwmst.com/4738.html)

   [ *并发编程面试专栏* ](https://zwmst.com/%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%e9%9d%a2%e8%af%95%e4%b8%93%e6%a0%8f)*[ <time datetime="2021-10-10T22:13:26+08:00"> 2021-10-10 </time> ](https://zwmst.com/4738.html)  **什么是线程池？**
很简单，简单看名字就知道是装有线程的池子，我们可以把要执行的多线程交给线程池来处理，和连接池的概念一样，通过维护一定数量的线程池来达到多个线程的复用。
**线程池的好处**
我们知道不用线程池的话，每个线程都要通过 new Thread(xxRunnable).start()的方式来创建并运行一个线程，线程少的话这不会是问题，而真实环境可能会开启多个线程让系统和程序达到最佳效率，当线程数达到一定数量就会耗尽系统的 CPU 和内存资源，也会造成 GC频繁收集和停顿，因为每次创建和销毁一个线程都是要消耗系统资源的，如果为每个任务都创建线程这无疑是一个很大的性能瓶颈。所以，线程池中的线程复用极大节省了系统资源，当线程一段时间不再有任务处理时它也会自动销毁，而不会长驻内存。
**线程池核心类**
在 java.util.concurrent 包中我们能找到线程池的定义，其中 ThreadPoolExecutor 是我们线程池核心类，首先看看线程池类的主要参数有哪些。
**如何提交线程**
如 可 以 先 随 便 定 义 一 个 固 定 大 小 的 线 程 池

```
ExecutorService es = Executors.newFixedThreadPool(3);
```

提交一个线程

```
es.submit(xxRunnble);
es.execute(xxRunnble);
```

**submit 和 execute 分别有什么区别呢？**
execute 没有返回值，如果不需要知道线程的结果就使用 execute 方法，性能会好很多。
submit 返回一个 Future 对象，如果想知道线程结果就使用 submit 提交，而且它能在主线程中通过 Future 的 get 方法捕获线程中的异常。
**如何关闭线程池**

```
es.shutdown();
```

不再接受新的任务，之前提交的任务等执行结束再关闭线程池。

```
es.shutdownNow();
```

不再接受新的任务，试图停止池中的任务再关闭线程池，返回所有未处理的线程list 列表。*