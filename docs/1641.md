<!--yml
category: 未分类
date: 0001-01-01 00:00:00
--->

# 288.服务跟踪（starter-sleuth）

> 原文：[https://zwmst.com/3574.html](https://zwmst.com/3574.html)

   [ *微服务* ](https://zwmst.com/%e5%be%ae%e6%9c%8d%e5%8a%a1)*[ <time datetime="2021-09-21T00:59:06+08:00"> 2021-09-20 </time> ](https://zwmst.com/3574.html)  随着微服务数量不断增长，需要跟踪一个请求从一个微服务到下一个微服务的传播过程， **Spring Cloud Sleuth 正是解决这个问题，它在日志中引入唯一 ID，以保证微服务调用之间的一致性，这样你就能跟踪某个请求是如何从一个微服务传递到下一个**。

1.  为了实现请求跟踪，当请求发送到分布式系统的入口端点时，只需要服务跟踪框架为该请求创建一个唯一的跟踪标识，同时在分布式系统内部流转的时候，框架始终保持传递该唯一标识，直到返回给请求方为止，**这个唯一标识就是前文中提到的 Trace ID**。通过 Trace ID 的记录，我们就能将所有请求过程日志关联起来。
2.  为了统计各处理单元的时间延迟，当请求达到各个服务组件时，或是处理逻辑到达某个状态时，也通过一个唯一标识来标记它的开始、具体过程以及结束，该标识就是我们前文中提到的 Span ID，**对于每个 Span 来说，它必须有开始和结束两个节点，通过记录开始 Span 和结束 Span 的时间戳，就能统计出该 Span 的时间延迟**，除了时间戳记录之外，它还可以包含一些其他元数据，比如：事件名称、请求信息等。
3.  在快速入门示例中，我们轻松实现了日志级别的跟踪信息接入，这完全归功于spring-cloud-starter-sleuth 组件的实现。在 Spring Boot 应用中，通过在工程中引入 spring-cloud-starter-sleuth 依赖之后， 它会自动的为当前应用构建起各通信通道的跟踪机制，比如：
    1.  通过诸如 RabbitMQ、Kafka（或者其他任何 Spring Cloud Stream 绑定器实现的消息中间件）传递的请求。
    2.  通过 Zuul 代理传递的请求。
    3.  通过 RestTemplate 发起的请求。*