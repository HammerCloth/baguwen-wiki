<!--yml
category: 未分类
date: 0001-01-01 00:00:00
--->

# Spring AOP 实现原理

> 原文：[https://zwmst.com/1887.html](https://zwmst.com/1887.html)

   [ *Spring* ](https://zwmst.com/spring)*[ <time datetime="2021-08-15T16:45:34+08:00"> 2021-08-15 </time> ](https://zwmst.com/1887.html)  实现AOP的技术，主要分为两大类：

一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执 行；二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间 织入有关“方面”的代码。

Spring AOP 的实现原理其实很简单：AOP 框架负责动态地生成 AOP 代理类，这个代理类的 方法则由 Advice和回调目标对象的方法所组成, 并将该对象可作为目标对象使用。AOP 代理包 含了目标对象的全部方法，但AOP代理中的方法与目标对象的方法存在差异，AOP方法在特定 切入点添加了增强处理，并回调了目标对象的方法。

Spring AOP使用动态代理技术在运行期织入增强代码。使用两种代理机制：基于JDK的动态代 理（JDK本身只提供接口的代理）和基于CGlib的动态代理。

(1) JDK的动态代理

JDK的动态代理主要涉及java.lang.reflect包中的两个类：Proxy和InvocationHandler。其 中InvocationHandler只是一个接口，可以通过实现该接口定义横切逻辑，并通过反射机制调 用目标类的代码，动态的将横切逻辑与业务逻辑织在一起。而Proxy利用InvocationHandler 动态创建一个符合某一接口的实例，生成目标类的代理对象。 其代理对象必须是某个接口的实现, 它是通过在运行期间创建一个接口的实现类来完成对目标 对象的代理.只能实现接口的类生成代理，而不能针对类。

(2)CGLib

CGLib采用底层的字节码技术，为一个类创建子类，并在子类中采用方法拦截的技术拦截所有 父类的调用方法，并顺势织入横切逻辑.它运行期间生成的代理对象是目标类的扩展子类.所以 无法通知final、private的方法,因为它们不能被覆写.是针对类实现代理,主要是为指定的类生 成一个子类，覆盖其中方法。 在spring中默认。况下使用JDK动态代理实现AOP,如果proxy-target-class设置为true或者 使用了优化策略那么会使用CGLIB来创建动态代理.Spring AOP在这两种方式的实现上基本 一样．以JDK代理为例，会使用JdkDynamicAopProxy来创建代理，在invoke()方法首先需 要织入到当前类的增强器封装到拦截器链中，然后递归的调用这些拦截器完成功能的织入，最 终返回代理对象。*